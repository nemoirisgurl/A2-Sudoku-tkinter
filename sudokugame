import tkinter as tk
from tkinter import messagebox, filedialog, ttk
import random

GRID_SIZE, MINI_GRID_SIZE = 9, 3
ANSWERS_GRID = [[0] * GRID_SIZE for _ in range(GRID_SIZE)]  # Store original grid
EDITABLE_GRID = [[0] * GRID_SIZE for _ in range(GRID_SIZE)]  # Track editable states (0 = editable, 1 = read-only)
is_revealed = False
entries = {}
hint_count , max_hint = 0, 0 
font_size, button_size, progress_bar_size = 14, 1, 300 # Default
progress_percentage = 0

def scale_widget():
    # Scale and update widget size 
    width, height = sudoku_game.winfo_width(), sudoku_game.winfo_height()
    new_font_size, new_GRID_SIZE, new_button_size, new_progress_bar_size = max(3, int(height / 60)), max(3, int(width / (GRID_SIZE + 450))), max(1, int(height / 60)), width / 3.2
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            entries[(row, col)].config(font=("Arial", (new_font_size + 8)), width=new_GRID_SIZE)
    for button_name, button in game_buttons.items():
        button.config(font=("Arial", new_font_size), width=new_button_size)     
    progress_bar.config(length=new_progress_bar_size)
    progress_label.config(font=("Arial", new_font_size))

def resize_widget(event):
    # Call scale_widget() when window is resized 
    scale_widget()

def validate_input(char):
    # Allow only numbers 1-9
    if (len(char) <= 1):
        if (char.isdigit() and 1 <= int(char) <= 9 or char == ""):
            return True  # Also allow clearing the entry
    return False

def create_grid(parent):
    # Create a 9x9 Sudoku grid with border
    vcmd = (sudoku_game.register(validate_input), "%P")  # Register validation function
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            # Alternate colors based on 3x3 blocks
            entry_color = "light yellow" if (row // MINI_GRID_SIZE + col // MINI_GRID_SIZE) % 2 == 0 else "light blue"
            top_border = 6 if row % MINI_GRID_SIZE == 0 else 1 # Highlight
            left_border = 6 if col % MINI_GRID_SIZE == 0 else 1
            bottom_border = 6 if row == GRID_SIZE - 1 else 1
            right_border = 6 if col == GRID_SIZE - 1 else 1
            border = tk.Frame(parent, highlightbackground="black", highlightthickness=1)
            border.grid(row=row, column=col, padx=(left_border, right_border), pady=(top_border, bottom_border))
            entry = tk.Entry(border, bg=entry_color, width=3, justify="center", font=("Arial", font_size + 8), validate="key", validatecommand=vcmd)
            entry.pack(padx=1, pady=1)
            entries[(row, col)] = entry  # Store Entry widget
            for key, direction in [("<Up>", (-1, 0)), ("<Down>", (1, 0)), ("<Left>", (0, -1)), ("<Right>", (0, 1)),
                                   ("<w>", (-1, 0)), ("<s>", (1, 0)), ("<a>", (0, -1)), ("<d>", (0, 1)),
                                   ("<W>", (-1, 0)), ("<S>", (1, 0)), ("<A>", (0, -1)), ("<D>", (0, 1))]:
                                   # Change grid by using keyboard
                entry.bind(key, lambda event, row=row, col=col, d=direction: move_grid(row + d[0], col + d[1]))

def move_grid(row, col):
    # Move focus to a specific cell, ensuring the row and column stay within bounds
    if (0 <= row < GRID_SIZE and 0 <= col < GRID_SIZE):
        entries[(row, col)].focus_set()

def check_possible_num(num, row, col):
    # Check if the number can be placed in the (row, col) position
    for j in range(GRID_SIZE):
        if (entries[(row, j)].get() == str(num) or entries[(j, col)].get() == str(num)):
            return False
    start_row = (row // MINI_GRID_SIZE) * MINI_GRID_SIZE
    start_col = (col // MINI_GRID_SIZE) * MINI_GRID_SIZE
    for i in range(MINI_GRID_SIZE):
        for j in range(MINI_GRID_SIZE):
            if (entries[(start_row + i, start_col + j)].get() == str(num)):
                return False
    return True

def is_empty(row, col):
    # Check if a given cell is empty
    return entries[(row, col)].get() == ""

def find_empty_spot():
    # Find the first empty spot in the grid
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if is_empty(row, col):
                return (row, col)
    return None  # No empty spots

def fill_grid():
    # Recursive function to fill the grid using backtracking
    empty_spot = find_empty_spot()
    if not empty_spot:
        return True  # Grid is fully filled
    row, col = empty_spot
    possible_num = list(range(1, 10))
    random.shuffle(possible_num)  # Shuffle to add randomness
    for num in possible_num:
        if check_possible_num(num, row, col):
            entries[(row, col)].delete(0, tk.END)
            entries[(row, col)].insert(0, num)
            ANSWERS_GRID[row][col] = num  # Store the number in the answers grid
            if fill_grid():  # Recursively fill the next spot
                return True
            # If filling with this number doesn't work, backtrack
            entries[(row, col)].delete(0, tk.END)
            ANSWERS_GRID[row][col] = 0  # Clear the answer in case of backtrack
    return False  # Trigger backtracking

def remove_numbers(remove_grid_count, mode): 
    # Remove numbers from grid
    global hint_count, max_hint, num_to_remove
    print(f"{remove_grid_count} grids has been removed")
    num_to_remove = remove_grid_count # Remove numbers
    if (mode == "randommode"):
        max_hint = 3
    if (max_hint > 0):    
        game_buttons["hint_button"].config(state="normal") 
    hint_count = 0
    all_cells = [(i, j) for i in range(GRID_SIZE) for j in range(GRID_SIZE)]
    random.shuffle(all_cells)  # Shuffle to randomly pick cells to clear
    # Remove numbers from a random set of cells
    for i in range(num_to_remove):
        row, col = all_cells[i]
        entries[(row, col)].delete(0, tk.END)
    lock_initial_numbers()

def lock_initial_numbers():
    # Lock the initially filled numbers and update the editable grid
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if entries[(row, col)].get() != "":
                entries[(row, col)].config(state="readonly")  # Lock the entry
                EDITABLE_GRID[row][col] = 1  # Mark as read-only
            else:
                EDITABLE_GRID[row][col] = 0  # Mark as editable

def hint():
    # Show hint on the random empty grids
    global hint_count, max_hint, EDITABLE_GRID
    if max_hint is not None:
        if (hint_count < max_hint):
            empty_grids = [(row, col) for row in range(GRID_SIZE) for col in range(GRID_SIZE) if is_empty(row, col)]
            if (empty_grids):
                row, col = random.choice(empty_grids)
                entries[(row, col)].delete(0, tk.END)
                entries[(row, col)].insert(0, ANSWERS_GRID[row][col])
                entries[(row, col)].config(state="readonly")
                EDITABLE_GRID[row][col] = 1
                hint_count += 1
                update_progress()
            if (hint_count >= max_hint):
                game_buttons["hint_button"].config(state="disabled")
        bind_entry_events()

def reset_grid():
    # Clear the grid for a new game
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            entries[(row, col)].config(state="normal", fg="black")  
            entries[(row, col)].delete(0, tk.END)
            ANSWERS_GRID[row][col] = 0
    progress_percentage = 0
    progress_label.config(text=f"Progress : {progress_percentage:.2f}%")
    progress_bar["value"] = progress_percentage  
    game_buttons["reveal_button"].config(text="Reveal", state="disable", command=reveal_grid)      
    game_buttons["load_button"].config(state="normal")

def is_grid_empty():
    # Check if all cells are empty
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if entries[(row, col)].get() != "":
                return False
    return True

def check_win():
    # Check if the current grid is a valid Sudoku solution
    for row in range(GRID_SIZE):
        row_nums = set()
        col_nums = set()
        for col in range(GRID_SIZE):
            row_val = entries[(row, col)].get()
            col_val = entries[(col, row)].get()
            if (row_val == "" or col_val == ""):
                return False  
            if (row_val in row_nums or not row_val.isdigit() or int(row_val) not in range(1, 10)): 
                return False  
            row_nums.add(row_val)
            if (col_val in col_nums or not col_val.isdigit() or int(col_val) not in range(1, 10)):
                return False  
            col_nums.add(col_val)
    # Check 3x3 blocks
    for block_row in range(0, GRID_SIZE, MINI_GRID_SIZE):
        for block_col in range(0, GRID_SIZE, MINI_GRID_SIZE):
            block_nums = set()
            for i in range(MINI_GRID_SIZE):
                for j in range(MINI_GRID_SIZE):
                    block_val = entries[(block_row + i, block_col + j)].get()
                    if block_val in block_nums:
                        return False  # Duplicates in block
                    block_nums.add(block_val)
    return True

def check_completion():
    # Check if the puzzle is complete and display win message
    if (check_win()):
        for row in range(GRID_SIZE):
            for col in range(GRID_SIZE):
                entries[(row, col)].config(fg="black")
        messagebox.showinfo("Victory", "You solved the puzzle!")
        progress_label.config(text=f"Progress : {100:.2f}%")
        game_buttons["reveal_button"].config(text="Clear", command=reset_grid)
        game_buttons["save_button"].config(state="disabled")
        # Clear grid

def on_entry_change(event):
    # Get the row and column of the entry that triggered the event
    if (is_revealed):
        return
    grid_input = event.widget
    for (row, col), entry in entries.items():
        if entry == grid_input:
            break       
    if (ANSWERS_GRID[row][col] != 0 and EDITABLE_GRID[row][col] == 0):
        # Check answer on each grid
        input_value = grid_input.get()
        if (input_value.isdigit()):
            if (input_value == str(ANSWERS_GRID[row][col])):
                grid_input.config(fg="green")  # Correct answer     
            else:
                grid_input.config(fg="red")    # Incorrect answer
        else:
            grid_input.config(fg="black")  # Reset color if entry is empty or invalid
    update_progress()                   
    check_completion()
    
def instruction(): 
    # Show game instruction
    messagebox.showinfo("Instruction","How to play Sudoku\n"
    "1. Fill in the grid so that each row, column, and 3x3 block contains the numbers 1-9.\n"
    "2. You can only place numbers 1-9 in each empty cell\n"
    "3. You cannot edit cells that locked\n"
    "                                  Have fun!                                            ")

def update_progress():
    global progress_percentage, num_to_remove
    correct_grids = 0
    total_grids = num_to_remove - hint_count
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if (entries[(row, col)].get() == str(ANSWERS_GRID[row][col]) and EDITABLE_GRID[row][col] == 0):
                correct_grids += 1
    game_progress = correct_grids / total_grids
    if (total_grids > 0):
        progress_percentage = game_progress * 100  
        progress_bar["value"] = progress_percentage
    else:
        progress_bar["value"] = 100
    progress_label.config(text=f"Progress : {progress_percentage:.2f}%")

def save_game(): 
    # Save game data
    file_path = filedialog.asksaveasfilename(defaultextension=".dat",
                                                   filetypes=[("Data Files", "*.dat"),
                                                              ("Text Files", "*.txt"),
                                                              ("All Files", "*.*")])
    try:
        if (file_path):
            with open(file_path, "w") as f:
                f.write("Saved grid\n")
                save_grid(f)
                f.write("Editable\n")
                save_editable_state(f)
                f.write("Answer\n")
                save_ANSWERS_GRID(f)
                f.write(f"Hints {hint_count}/{max_hint}\n")
                f.write(f"Difficulty : {num_to_remove - hint_count}")                
            messagebox.showinfo("Save Game", "Game has been saved.")
        else:
            return    
    except Exception as e:
        messagebox.showerror("Save Game", f"An error occurred while saving: {e}")

def save_grid(file):
    # Save progress
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            save_value = entries[(row, col)].get() or "0"
            file.write(save_value + " ")
        file.write("\n")

def save_editable_state(file):
    # Save editable state
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            save_edit = str(EDITABLE_GRID[row][col]) 
            file.write(save_edit + " ")
        file.write("\n")    

def save_ANSWERS_GRID(file):
    # Save answers
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            save_value = str(ANSWERS_GRID[row][col])
            file.write(save_value + " ")
        file.write("\n")    

def load_game(): 
    # Load game data 
    file_path = filedialog.askopenfilename(filetypes=[("Data Files", "*.dat"),
                                                      ("Text Files", "*.txt"), 
                                                      ("All Files", "*.*")])
    try:
        if (file_path):
            # If you confirm to load
            reset_grid()  # Clear the existing grid
            with open(file_path, "r") as f:
                f.readline()
                load_grid(f)
                f.readline()
                load_edit_state(f)    
                f.readline()
                load_ANSWERS_GRID(f)
                bind_entry_events()
                load_hint(f)
                global num_to_remove
                num_to_remove = int(f.readline().split(" : ")[1])
                load_progress()
            messagebox.showinfo("Load Game", "Game successfully loaded.")
            game_buttons["save_button"].config(state="normal")
            game_buttons["load_button"].config(state="normal")
            game_buttons["reveal_button"].config(state="normal")
            if (hint_count < max_hint):
                game_buttons["hint_button"].config(state="normal") 
        else:
            return        
    except FileNotFoundError:
        messagebox.showwarning("Load Game", "No saved game found.")
    except Exception as e:
        messagebox.showerror("Load Game", f"An error occurred while loading: {e}")

def load_grid(file):
    # Load saved grid
    for row in range(GRID_SIZE):
        line = file.readline().strip().split()
        for col in range(GRID_SIZE):
            value = line[col]
            entries[(row, col)].delete(0, tk.END) 
            if (value != "0"):
                entries[(row, col)].insert(0, value)

def load_edit_state(file):
    # Load editable state 
    for row in range(GRID_SIZE):
        line = file.readline().strip().split()
        for col in range(GRID_SIZE):
            editable_value = int(line[col])
            EDITABLE_GRID[row][col] = editable_value
            if (editable_value) == 1:  
                entries[(row, col)].config(state="readonly")
            else:
                entries[(row, col)].config(state="normal")

def load_ANSWERS_GRID(file):
    # Load answers
    for row in range(GRID_SIZE):
        line = file.readline().strip().split()
        for col in range(GRID_SIZE):
            ANSWERS_GRID[row][col] = int(line[col])   

def load_hint(file):
    # Load and update hint and max hints
    hint_line = file.readline().strip().split()
    global hint_count, max_hint
    hint_count, max_hint = map(int, hint_line[1].split("/"))

def load_progress():
    # Load game progress
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            load_input = entries[(row, col)].get()
            if (load_input.isdigit() and EDITABLE_GRID[row][col] == 0 ):
                if (load_input == str(ANSWERS_GRID[row][col])):
                    entries[(row, col)].config(fg="green")
                else:
                    entries[(row, col)].config(fg="red")
            else:
                entries[(row, col)].config(fg="black")
    update_progress()            
    
def show_game_buttons(parent): 
    # Game button
    global game_buttons
    game_buttons = {}
    # Create game buttons (New game, Reveal answers, Save game, Load game)
    game_buttons['reset_button'] = tk.Button(parent, text="New game", font=("Arial", font_size), command=new_game_setting)
    game_buttons['reveal_button'] = tk.Button(parent, text="Reveal", font=("Arial", font_size), command=reveal_grid, state="disabled")
    game_buttons['save_button'] = tk.Button(parent, text="Save game", font=("Arial", font_size), command=save_game, state="disabled")
    game_buttons['load_button'] = tk.Button(parent, text="Load game", font=("Arial", font_size), command=load_game)
    game_buttons['hint_button'] = tk.Button(parent, text="Hint", font=("Arial", font_size), command=hint, state="disabled")
    game_buttons['instruction_button'] = tk.Button(parent, text="Instruction", font=("Arial", font_size), command=instruction)
    game_buttons['exit_button'] = tk.Button(parent, text="Quit game", font=("Arial", font_size), command=exit_game)
    game_buttons['reset_button'].grid(row=1, column=0, padx=5, pady=10)
    game_buttons['load_button'].grid(row=1, column=1, padx=5, pady=10)
    game_buttons['save_button'].grid(row=1, column=2, padx=5, pady=10)
    game_buttons['hint_button'].grid(row=1, column=3, padx=5, pady=10)
    game_buttons['reveal_button'].grid(row=1, column=4, padx=5, pady=10)
    game_buttons['instruction_button'].grid(row=2, column=1, padx=5, pady=10)
    game_buttons['exit_button'].grid(row=2, column=3, padx=5, pady=10)

def create_progress_bar(parent):
    global progress_label, progress_bar
    progress_label = tk.Label(parent, text=f"Progress : {progress_percentage:.2f}%", font=("Arial", font_size + 2))
    progress_bar = ttk.Progressbar(parent, orient="horizontal", length=progress_bar_size, mode="determinate")
    progress_label.grid(row=0, column=0, columnspan=2, padx=5, pady=10)    
    progress_bar.grid(row=0, column=2, columnspan=3, padx=5, pady=10)

def reveal_grid():
    if (messagebox.askyesno("Reveal", "Are you sure to reveal and end the game?")):
        global is_revealed
        # Reveal correct answer
        for row in range(GRID_SIZE):
            for col in range(GRID_SIZE):
                entries[(row, col)].config(state="normal")  # Make editable
                entries[(row, col)].delete(0, tk.END)
                entries[(row, col)].insert(0, ANSWERS_GRID[row][col])  # Insert the original number
                entries[(row, col)].config(state="readonly")
                entries[(row, col)].config(fg="black")  # Lock after revealing
        progress_label.config(text=f"Progress : -.--%")
        game_buttons["reveal_button"].config(state="disabled") # Disable "Reveal" button
        game_buttons["save_button"].config(state="disabled") # Disable "Save game" button  
        game_buttons["hint_button"].config(state="disabled") # Disable "Load game" button
        is_revealed = True
    else:
        return

def bind_entry_events():
    # Bind key release event to each entry widget to check for completion
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            if (not entries[(row, col)].bind("<KeyRelease>")):
                entries[(row, col)].bind("<KeyRelease>", on_entry_change)         
                
def random_mode():
    global is_revealed
    # Random mode (Reset grid then generate new Sudoku)
    is_revealed = False
    reset_grid()
    fill_grid() 
    # Save the fully solved grid before removing any numbers
    for row in range(GRID_SIZE):
        for col in range(GRID_SIZE):
            ANSWERS_GRID[row][col] = int(entries[(row, col)].get())  # Save the number in the answers grid
    bind_entry_events()
    game_buttons["reset_button"].config(state="normal") 
    game_buttons["reveal_button"].config(state="normal")  
    game_buttons["save_button"].config(state="normal") 

def custom_mode():
    # Custom mode (Input a hint and a number of grids to be removed)
    custom_mode_window = tk.Toplevel()
    custom_mode_window.geometry("350x250")
    custom_mode_window.resizable(False, False)
    custom_mode_window.title("Custom Mode")
    def entry_check(char):
        if ((char.isdigit() or char == "") and len(char) <= 2 ):
            return True   
        return False
    def get_remove_number():
        try:
            remove_grid_count = int(custom_mode_entry.get())
            global max_hint
            max_hint = int(hint_entry.get())
            if (0 < remove_grid_count < GRID_SIZE * GRID_SIZE):
                if (max_hint < remove_grid_count):
                    random_mode()
                    remove_numbers(remove_grid_count, "custommode")
                    custom_mode_window.destroy()
                else:
                    messagebox.showwarning("Error", f"Please enter hints lower than {remove_grid_count}")
            else:
                messagebox.showwarning("Error", f"Please enter the number between 1 and {GRID_SIZE * GRID_SIZE - 1}")
        except ValueError:
            messagebox.showwarning("Error", "Invaild input!")         
    vcmd = (custom_mode_window.register(entry_check), "%P")        
    custom_mode_label = tk.Label(custom_mode_window, text="Enter a number of grids to be removed ", font=("Arial", font_size))
    custom_mode_entry = tk.Entry(custom_mode_window, font=("Arial", font_size), width= 4, justify="center" ,validate="key", validatecommand=vcmd)
    hint_label = tk.Label(custom_mode_window, text="Enter a number of hints ", font=("Arial", font_size))
    hint_entry = tk.Entry(custom_mode_window, font=("Arial", font_size), width= 4, justify="center" ,validate="key", validatecommand=vcmd)
    confirm_button = tk.Button(custom_mode_window, text="Start Game", font=("Arial", font_size), command=get_remove_number)
    custom_mode_label.pack(pady=10)
    custom_mode_entry.pack(pady=10)
    hint_label.pack(pady=10)
    hint_entry.pack(pady=10)
    confirm_button.pack(pady=10)

def difficulty_select():
    difficulty_name = [["Easy", (11, 30)], 
                       ["Normal", (31, 50)], 
                       ["Hard", (51, 70)], 
                       ["Extreme", (71, GRID_SIZE * GRID_SIZE - 1)]]
    difficulty_select_window = tk.Toplevel()
    difficulty_select_window.geometry("275x225")
    difficulty_select_window.resizable(False, False)
    difficulty_select_window.title("Choose difficulty")
    difficulty_select_label= tk.Label(difficulty_select_window, text="Choose difficulty", font=("Arial", font_size + 8))
    difficulty_select_label.grid(row=0, column=0, columnspan=2, padx=30, pady=20)
    for i, (label, difficulty_range) in enumerate(difficulty_name):
        difficulty_button = tk.Button(difficulty_select_window, text=label, font=("Arial", font_size), command=lambda range = difficulty_range:[random_mode(),
                                                                                            remove_numbers(random.randint(range[0], range[1]), "randommode"),
                                                                                            difficulty_select_window.destroy()])
        difficulty_button.grid(row=(1 + i // 2), column=(i % 2), padx=30, pady=10) 

def exit_game():
    # Exit game
    is_quit = messagebox.askyesno("Quit", "Are you sure to quit?\nYour game progress will not be saved.")
    if (is_quit):
        sudoku_game.destroy()
    else:
        return
    
def new_game_setting():
    # Choose to remove random or custom numbers to be removed
    game_buttons["reset_button"].config(state="disabled")
    new_game_setting = tk.Toplevel()
    new_game_setting.geometry("350x250")
    new_game_setting.resizable(False, False)
    new_game_setting.title("New Game")
    mode_selection = tk.Label(new_game_setting, text="Choose mode", font=("Arial", font_size + 8))
    random_mode_button = tk.Button(new_game_setting, text="Random", font=("Arial", font_size), command=lambda:[difficulty_select(), new_game_setting.destroy()])
    random_mode_label = tk.Label(new_game_setting, text="Will select difficulty", font=("Arial", font_size - 2))
    custom_mode_button = tk.Button(new_game_setting, text="Custom", font=("Arial", font_size), command=lambda:[custom_mode(), new_game_setting.destroy()])
    custom_mode_label = tk.Label(new_game_setting, text="Will remove a certain number of grids", font=("Arial", font_size - 2))
    mode_selection.pack(pady=5)
    random_mode_button.pack(pady=5)
    random_mode_label.pack(pady=5)
    custom_mode_button.pack(pady=5)
    custom_mode_label.pack(pady=5)
    new_game_setting.wait_window()
  
def main():
    # Main function of Sudoku game
    sudoku = tk.Label(sudoku_game, text="Sudoku", font=("Arial", font_size * 3))
    sudoku.pack(pady= 10)
    top_frame = tk.Frame(sudoku_game)
    bottom_frame = tk.Frame(sudoku_game)
    top_frame.pack(side="top", padx=75)
    bottom_frame.pack(side="bottom", padx=15, pady=(0, 10))
    # Set up the grid and buttons
    create_grid(top_frame) # Show Sudoku grid
    create_progress_bar(bottom_frame) # Show progress bar
    show_game_buttons(bottom_frame) # Show buttons    

# Create the main window for the application
sudoku_game = tk.Tk()
sudoku_game.geometry("960x600") # Default window size
sudoku_game.title("SudokuGame")
sudoku_game.minsize(720, 600) # Minimum window size
sudoku_game.bind("<Configure>", resize_widget)

if __name__ == "__main__":
    main()
    sudoku_game.mainloop()
